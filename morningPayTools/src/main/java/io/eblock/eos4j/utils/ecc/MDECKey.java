package io.eblock.eos4j.utils.ecc;

import io.eblock.eos4j.ecc.Point;
import io.eblock.eos4j.ecc.Secp256k;
import io.eblock.eos4j.utils.Base58;
import io.eblock.eos4j.utils.ByteUtils;
import io.eblock.eos4j.utils.EException;
import io.eblock.eos4j.utils.Ripemd160;
import org.bitcoinj.core.ECKey;
import org.bitcoinj.core.Sha256Hash;
import org.bitcoinj.core.Utils;
import org.spongycastle.math.ec.ECPoint;
import org.spongycastle.util.encoders.Base64;

import java.math.BigInteger;
import java.security.SignatureException;
import java.util.Arrays;

public class MDECKey extends ECKey {

    ECDSASignature sig = null;
    ECKey key = null;
    /**
     * Given an arbitrary piece of text and a Bitcoin-format message signature encoded in base64, returns an ECKey
     * containing the public key that was used to sign it. This can then be compared to the expected public key to
     * determine if the signature was correct. These sorts of signatures are compatible with the Bitcoin-Qt/bitcoind
     * format generated by signmessage/verifymessage RPCs and GUI menu options. They are intended for humans to verify
     * their communications with each other, hence the base64 format and the fact that the input is text.
     *
     * @param message Some piece of human readable text.
     * @param signatureBase64 The Bitcoin-format message signature in base64
     * @throws SignatureException If the public key could not be recovered or if there was a signature format error.
     */
    public  boolean ReCoverFromSignedMessage(String message, String signatureBase64) {
        byte[] signatureEncoded;

        try {
            signatureEncoded = Base58.decode(signatureBase64);
        } catch (RuntimeException e) {
            // This is what you get back from Bouncy Castle if base64 doesn't decode :(
           return false;
        }
        // Parse the signature bytes into r/s and the selector value.
        if (signatureEncoded.length < 65)
            return false;
        int header = signatureEncoded[0] & 0xFF;
        // The header byte: 0x1B = first key with even y, 0x1C = first key with odd y,
        //                  0x1D = second key with even y, 0x1E = second key with odd y
        if (header < 27 || header > 34)
            return false;
        BigInteger r = new BigInteger(1, Arrays.copyOfRange(signatureEncoded, 1, 33));
        BigInteger s = new BigInteger(1, Arrays.copyOfRange(signatureEncoded, 33, 65));
        sig = new ECDSASignature(r, s);
        byte[] messageBytes = Utils.formatMessageForSigning(message);
        // Note that the C++ code doesn't actually seem to specify any character encoding. Presumably it's whatever
        // JSON-SPIRIT hands back. Assume UTF-8 for now.
        Sha256Hash messageHash = Sha256Hash.of(message.getBytes());
        boolean compressed = false;
        if (header >= 31) {
            compressed = true;
            header -= 4;
        }
        int recId = header - 27;
         key = ECKey.recoverFromSignature(recId, sig, messageHash, compressed);


      return  key != null&&key.isPubKeyOnly();
    }

    public boolean  verfiy(String message, String signatureBase64)
    {
        if(ReCoverFromSignedMessage(message,signatureBase64))
        {
            return key.verify(Sha256Hash.of(message.getBytes()),sig);
        }
        return false;
    }

    public static final String address_prefix = "EOS";

    public static final Secp256k secp = new Secp256k();

    public String GetEosPubKey() {

        ECPoint te = key.getPubKeyPoint();
        byte[] pub_buf = te.getEncoded();
        byte[] csum = Ripemd160.from(pub_buf).bytes();
        csum = ByteUtils.copy(csum, 0, 4);
        byte[] addy = ByteUtils.concat(pub_buf, csum);
        StringBuffer bf = new StringBuffer(address_prefix);
        bf.append(Base58.encode(addy));
        return bf.toString();
    }

}
